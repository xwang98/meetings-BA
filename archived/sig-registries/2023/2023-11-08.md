## Nov 8, 2023 - SIG Registries meeting

|          |      | 
| -------- | -------- |
| Attending  | Calvin Prewitt, Lann Martin, Kyle Brown, Luke Wagner, Peter Huene, Timmy Silesmo, Danny Macovei, Chris Dickinson;
| Note Taker | Chris Dickinson

Updates:
- [Calvin] PR for monitors and federation almost ready for review;
- [Lann] Update from last week on namespaces: https://github.com/bytecodealliance/registry/issues/224


Agenda:
- [Calvin] Permissions in the operator and package logs;
    - See Kyle doc: [Hierarchical Delegation](https://hackmd.io/F3Lv9F0GTf62GOo_PtxqMw)
- [Calvin] BA Registry options;

Minutes:

- kyle:
    - we've gone in the direction of treating the mapping between namespaces and the origins that define those ns as state of the operator
        - `wasi -> registry.wasi.dev` is an entry
        - alternatively, if the registry defines a namespace, it has an entry that says "I define BA"
        - if the cli follows the same mappings as the registry, packages generated by the cli are publishable to that registry
        - calvin: we're adding entry types to the operator log to forward declare that namespaces belong to the registry or that the namespace is imported from another registry (and it says what the registry is)
        - kyle: the big piece is to make the client do something with this, this is an interaction between the `warg-registry` header and the monitor endpoint
            - you can use the warg-registry header to talk _through_ a registry to a destination registry.
            - lann: not a lot of point to a pure registry readthrough – could use a proxy
            - kyle: the mirror can provide its own proofs, in case the backing registries go away
        - kyle: we're in broad agreement about the warg-registry header; if we can work towards getting monitoring, we can unlock a lot of federation features
    - calvin: [link to updated openapi spec in chat](https://redocly.github.io/redoc/?url=https://raw.githubusercontent.com/calvinrp/bytecodealliance-registry/monitors-and-federation-server-side/crates/server/openapi.yaml)
        - introduces three new endpoints
            - verify checkpoint endpoint
            - fetch ledger sources endpoint (allows you to get the log id, record id, ledger stream; & optionally use range headers for that)
            - package id/name from a log id (POST a log id sha, if the server is able to provide it, it will return that – if not it could be delisted, via some kind of takedown, so it has the option of not giving the id)
                - calvin: it's under "/fetch/ids"; I could add "package-ids"
                - kyle: this is a branch where the trifecta of the three things we've been talking about [are implemented]
                - one q: the package-ids is a fourth thing beyond the three minimum things. I don't think we've had a lot of design discussion about this – why include this in the branch?
                - calvin: I didn't discuss it with the full group but I discussed with lann. Talked about it being a POST or some paginated list; I was leaning towards a POST with the log ids and get the package id from that.
                - the reason I wanted this in the PR is that this is the one last thing you can't get from a registry today; this is problematic for trying to list what's in another registry in any material way
                - kyle: the driving use case is "registry to registry, when you arrive at a new id, you want to get the set of [those names]"
                - that seems reasonable to me
                - calvin: do you like the api design with the POST?
                - kyle: yes; my only question is really where we put it in the api – the path
                - calvin: right now it's under `/fetch/ids`, but.
                    - if the server doesn't fulfill the ids because there are too many, it omits the ones that didn't fit – with the intention that the client retries with the missing hashes
                    - lann: i'm going to have feedback about the specifics of that schema, but the feature sounds good to me
                - calvin: could I start a PR–
                - kyle: could you start an issue? the PR is going to involve four different features – for bookkeeping it might be good to create all four issues and link the PR to each of these to show that it solves all of these.
                    - it might be good to have an issue for the warg-registry part just so there's some on-the-record bits about this
                    - can I work with you offline to file issues for these things?
                    - calvin: sounds reasonable
                - kyle: it's been on our list to have an "issues drive implementation" process
                - lann: strive to have an issue for any substantive topic we're discussing
                - kyle: one question about the API – is it IDs that are being fetched? what is the name for a "blank:blank" string? is it a name or an id?
                - luke: for a while we were saying "id"; now the grammar has different kinds of "names"; so now it's "interface name" or "package name".
                - calvin: rename to `package-names`?
                - [general agreement]
- calvin: permissions
    - one thing that came up when i was implementing this for the operator log for namespaces; there's only one permission in the operator log and it's "commit"
    - couple of questions:
        1. operator key is used for signing checkpoints and changing the operator log; do we want finer grained permissions – do we want one that can sign but not change the log?
            - kyle: for now i would hope we would make these two new issues map to new permissions
            - it would be great to give something commit but not import
            - lann: it would be a good security feature to have the checkpoint key only do checkpoint signing, everything else could be offline
            - calvin: it's signing a timestamp checkpoint, so it's kind of like freshness, as well
            - kyle: the idea is that there are no other entries in the operator log – the only permission it has is "commit"
            - calvin: how do we revoke keys?
            - kyle: you can only revoke something you yourself have
                - commit is the special permission
            - calvin: would you consider renaming it?
            - kyle: I would consider it, commit has multiple meanings
            - lann: commit is appropriate – it's committing a transaction in a sense
            - calvin: I'll update the doc, at least – it was unclear what that meant to me
            - lann: rather than making commit the special permission, we might want to have an authorized committer
            - kyle: would be nice if this part of the perms rewrite
                - we built a monotonic counter; we'd make all logs made since the change have a new version; new packages get to start using it, and figure out how to rotate into it for old ones
            - calvin: what should be our path forward on going through with these changes? actually figuring out the [delegated permissions](https://hackmd.io/F3Lv9F0GTf62GOo_PtxqMw)?
                - kyle: I'll open an issue for it. who wants to assign themselves to it?
                - they'll need clarification from me
                - next step is for someone to say "this is mine and i'm going to do it"
                - calvin: this is the last change that would require rewriting history?
                    - kyle: luke mentioned pulling the operator log out – [cd – I missed this]
    - [discussion of trust reset]
        - calvin: move this to github discussion?
    - calvin: before we go to delegated perms, do we want the ability to do a "rotate" as an operation, vs a grant+revoke?
        - kyle: because I want to solve this with a new perm system, I'd rather spend the effort on the new system
        - lann: atomic multi-entry records allow you to do both
        - kyle: and you can revoke self, yes?
            - if not possible, I'd allow that
        - calvin: in your proposal granting and revoking are permissions but rotation is always allowed
        - kyle: it's kind of a terminal permission – there's a limit attached to your permission that you're not allowed to propagate that permission
- calvin: discuss BA registry
    - do we want one? what would be in it if we had one?
    - from my discussions with people, it would be BA projects, not open to the public for publishing
    - what projects would we want in there?
    - kyle: at a minimum, the BA needs a registry to publish WASM tools
        - lann: wasi? adaptors?
        - kyle: compose, bindgen, adaptors – the BA is deploying these things
    - lann: we don't distribute any other release artifacts that are wasm
    - kyle: we'll want to publish our tools as wasm
    - calvin: wasi-virt?
    - kyle: component-bindgen, maybe?
        - it makes sense that we'll want to publish a lot of our tools as components
    - lann: do we think there's a separate server running wasi? i assumed it'd be a namespace in the BA registry
    - luke: was thinking that WASI would have it's own thing, vaguely owned by the w3c
    - kyle: my thought was that we could lean on federation; some combination of downstreams could take load off of the WASI registry
        - this also helps with optics
    - lann: practically, it's going to be the same person/people operating them, at least in the medium term
    - kyle: is the wasm CG/w3c going to want its own registry?
        - again, this might be the same people running the same reference impl
    - luke: optically it's good to have `wasi.webassembly.org`, then `registry.bytecodealliance.org`. Maybe we can put `mirror.` in the name in the meantime? It'd be great to have wasi served from a webassembly.org domain, once federation is available?
    - calvin: wasi is just interfaces, and since interfaces – when you're publishing components using an interface, you're not having to talk to another registry – really what the wasi registry would be is the source of truth for bindgen tools. Not a lot of dynamic bundling.
    - luke: till in the earliest days said "in order to make a breaking change you have to publish a component that shims those changes" [cd paraphrase]
    - kyle: polyfill components
    - a wasi-to-wasi adapter definitely feels reasonable – anything that's part of guest tooling maybe doesn't belong in wasi
    - calvin: it sounds like we want something as a registry; there's options – there's our reference impl, which is usable but not necessarily scalable, would take some work to make it scale. If the federation proposal goes through, we'll have the option to have mirrors relatively easily. One option that I've been kind of floating around is that we run the reference impl as the source of truth but we – the service I'm working on will be online this month, and we could run it as a mirror for wider distribution.
        - it wouldn't accept publishes itself, those would have to go to the ref impl, but you could have a mirror of the content as well as being able to fulfill the proof endpoints that wouldn't put load on the reference impl server
        - kyle: at minimum, in a split arch where we have the ref impl doing the internal publisher side of things and a prod-grade mirror, [cd can't keep up! apologies!!]
- lann: fermyon and (i imagine) fastly will have our own internal thing; and whether that's the ref impl or not...
- kyle: fastly/fermyon might get on the allow-lists for mirrors
- ref impl just needs to be good at being mirrored
- calvin: does this sound like the path we should take?
    - lann: it definitely sound like a use case to enable? it's a little early for me to know what the final impl looks like
    - kyle: it might be reasonable for the registry to have an endpoint where it tells the client about existing mirrors – it could suggest other registries when under load; clients could be smart enough to follow these suggestions

### action items:

- calvin to update the doc on permissions and add permissions for new entries
- kyle to start discussion on trust reset and an issue for delegation
